package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"os/exec"
	"strings"

	"github.com/panozzaj/roost-dev/internal/diff"
)

// cmdPorts handles the 'ports' command for managing port forwarding
func cmdPorts(args []string) {
	if len(args) == 0 {
		printPortsUsage()
		os.Exit(0)
	}

	subcmd := args[0]
	subargs := args[1:]

	switch subcmd {
	case "install":
		cmdPortsInstall(subargs)
	case "uninstall":
		cmdPortsUninstall(subargs)
	case "-h", "--help", "help":
		printPortsUsage()
		os.Exit(0)
	default:
		fmt.Fprintf(os.Stderr, "Unknown ports command: %s\n\n", subcmd)
		printPortsUsage()
		os.Exit(1)
	}
}

func printPortsUsage() {
	fmt.Println(`roost-dev ports - Manage port forwarding

USAGE:
    roost-dev ports <command>

COMMANDS:
    install     Setup port forwarding (80→9280, 443→9443)
    uninstall   Remove port forwarding configuration

Use 'roost-dev status' to check port forwarding status.

DESCRIPTION:
    Manages macOS pf (packet filter) rules that forward ports 80 and 443
    to roost-dev, allowing you to access apps at http://myapp.test without
    specifying a port number.`)
}

// cmdPortsInstall handles the 'ports install' command (also legacy 'install')
func cmdPortsInstall(args []string) {
	fs := flag.NewFlagSet("ports install", flag.ExitOnError)

	var (
		tld       string
		configDir string
	)

	fs.StringVar(&tld, "tld", "test", "Top-level domain to configure")
	fs.StringVar(&configDir, "dir", getDefaultConfigDir(), "Configuration directory")

	fs.Usage = func() {
		fmt.Println(`roost-dev ports install - Setup port forwarding

USAGE:
    roost-dev ports install [options]

OPTIONS:`)
		fs.PrintDefaults()
		fmt.Println(`
DESCRIPTION:
    Sets up macOS pf (packet filter) rules to forward ports to roost-dev,
    and creates a DNS resolver for the TLD. This allows accessing apps at
    http://myapp.test without specifying a port.

    Port forwarding:
      - Port 80  → 9280 (HTTP)
      - Port 443 → 9443 (HTTPS)

    Requires sudo for system configuration.

EXAMPLES:
    roost-dev ports install              # Setup for .test (default)
    roost-dev ports install --tld dev    # Setup for .dev TLD`)
	}

	// Check for help before parsing
	for _, arg := range args {
		if arg == "-h" || arg == "--help" || arg == "help" {
			fs.Usage()
			os.Exit(0)
		}
	}

	fs.Parse(args)

	if err := runPortsInstall(configDir, tld); err != nil {
		log.Fatalf("Port forwarding install failed: %v", err)
	}
}

// cmdPortsUninstall handles the 'ports uninstall' command (also legacy 'uninstall')
func cmdPortsUninstall(args []string) {
	fs := flag.NewFlagSet("ports uninstall", flag.ExitOnError)

	var tld string
	fs.StringVar(&tld, "tld", "test", "Top-level domain to remove")

	fs.Usage = func() {
		fmt.Println(`roost-dev ports uninstall - Remove port forwarding config

USAGE:
    roost-dev ports uninstall [options]

OPTIONS:`)
		fs.PrintDefaults()
		fmt.Println(`
DESCRIPTION:
    Removes the pf anchor file and DNS resolver (if using custom TLD).
    Does not modify /etc/pf.conf - you may want to manually remove
    the roost-dev lines or restore from the backup.

    Requires sudo for system configuration.

EXAMPLES:
    roost-dev ports uninstall              # Remove .test config (default)
    roost-dev ports uninstall --tld dev    # Remove .dev TLD config`)
	}

	// Check for help before parsing
	for _, arg := range args {
		if arg == "-h" || arg == "--help" || arg == "help" {
			fs.Usage()
			os.Exit(0)
		}
	}

	fs.Parse(args)

	if err := runPortsUninstall(tld); err != nil {
		log.Fatalf("Port forwarding uninstall failed: %v", err)
	}
}

// getPfAnchorContent returns the pf anchor file content
func getPfAnchorContent() string {
	return `# roost-dev port forwarding rules
# Forward port 80 to 9280 for roost-dev HTTP (IPv4)
rdr pass on lo0 inet proto tcp from any to any port 80 -> 127.0.0.1 port 9280
# Forward port 443 to 9443 for roost-dev HTTPS (IPv4)
rdr pass on lo0 inet proto tcp from any to any port 443 -> 127.0.0.1 port 9443
# Forward port 80 to 9280 for roost-dev HTTP (IPv6)
rdr pass on lo0 inet6 proto tcp from any to any port 80 -> ::1 port 9280
# Forward port 443 to 9443 for roost-dev HTTPS (IPv6)
rdr pass on lo0 inet6 proto tcp from any to any port 443 -> ::1 port 9443
`
}

// getResolverContent returns the DNS resolver file content
func getResolverContent() string {
	return "# Generated by roost-dev\nnameserver 127.0.0.1\nport 9053\n"
}

// portsInstallPlan returns a Plan for port forwarding installation.
// The same Plan is used for both preview and execution to ensure they stay in sync.
func portsInstallPlan(tld string) *diff.Plan {
	plan := diff.NewPlan()

	// pf anchor file
	plan.CreateStatic(pfAnchorPath, getPfAnchorContent())

	// LaunchDaemon plist
	plan.CreateStatic(launchdPlistPath, expectedPfPlistContent)

	// DNS resolver
	if tld != "localhost" {
		resolverPath := fmt.Sprintf("/etc/resolver/%s", tld)
		plan.CreateStatic(resolverPath, getResolverContent())
	}

	return plan
}

// portsUninstallPlan returns a Plan for port forwarding removal.
// The same Plan is used for both preview and execution to ensure they stay in sync.
func portsUninstallPlan(tld string) *diff.Plan {
	plan := diff.NewPlan()

	plan.Delete(pfAnchorPath)
	plan.Delete(launchdPlistPath)
	if tld != "localhost" {
		plan.Delete(fmt.Sprintf("/etc/resolver/%s", tld))
	}

	return plan
}

// confirmPortsInstall shows a summary and confirms port forwarding installation.
// Returns true if confirmed, false if cancelled or no changes needed.
func confirmPortsInstall(tld, prompt string) bool {
	if os.Getenv("ROOST_DEV_YES") == "1" {
		return true
	}

	plan := portsInstallPlan(tld)
	summary := plan.Summary()

	// Check if pf.conf needs modification (not in plan since it's complex)
	pfConf, err := os.ReadFile("/etc/pf.conf")
	pfConfNeedsUpdate := err == nil && !strings.Contains(string(pfConf), "roost-dev")

	// If no changes at all, return true (nothing to do)
	if summary == nil && !pfConfNeedsUpdate {
		return true
	}

	// Print summary
	fmt.Println()
	if summary != nil {
		summary.Print()
	}
	if pfConfNeedsUpdate {
		fmt.Printf("  %s~%s /etc/pf.conf (modified)\n", colorYellow, colorReset)
		fmt.Println()
	}

	for {
		fmt.Printf("%s [y/N, ? for diff]: ", prompt)
		var response string
		fmt.Scanln(&response)

		switch response {
		case "y", "Y":
			return true
		case "?":
			fmt.Println()
			plan.Preview()
			if pfConfNeedsUpdate {
				fmt.Printf("%s~~~ /etc/pf.conf (will be modified)%s\n", colorCyan, colorReset)
				fmt.Printf("%s  Will add after com.apple anchors:%s\n", colorDim, colorReset)
				fmt.Printf("%s    rdr-anchor \"roost-dev\"%s\n", colorDim, colorReset)
				fmt.Printf("%s    load anchor \"roost-dev\" from \"/etc/pf.anchors/roost-dev\"%s\n", colorDim, colorReset)
				fmt.Println()
			}
		default:
			return false
		}
	}
}

func runPortsInstall(configDir, tld string) error {
	// If not running as root, check for conflicts and re-invoke with sudo
	if os.Geteuid() != 0 {
		// Check for conflicts before asking for sudo
		if err := checkInstallConflicts(tld); err != nil {
			return err
		}

		// Show summary and confirm (? shows full diff)
		fmt.Println("Port forwarding requires administrator privileges.")
		if !confirmPortsInstall(tld, "Proceed with installation?") {
			return fmt.Errorf("installation cancelled")
		}
		fmt.Println()

		// Find our binary
		exe, err := os.Executable()
		if err != nil {
			return fmt.Errorf("finding executable: %w", err)
		}

		// Re-invoke with sudo
		args := []string{exe, "ports", "install", "--tld", tld, "--dir", configDir}
		cmd := exec.Command("sudo", args...)
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		cmd.Stdin = os.Stdin
		return cmd.Run()
	}

	// Running as root - do the actual install
	fmt.Println("Installing port forwarding...")

	// Save TLD to config so we don't need --tld flag every time
	if err := saveGlobalConfig(configDir, &GlobalConfig{TLD: tld}); err != nil {
		fmt.Printf("Warning: could not save config: %v\n", err)
	}

	// Ensure resolver directory exists for custom TLD
	if tld != "localhost" {
		if err := os.MkdirAll("/etc/resolver", 0755); err != nil {
			return fmt.Errorf("creating resolver directory: %w", err)
		}
	}

	// Execute the plan for file creation (same plan used for preview, ensuring sync)
	plan := portsInstallPlan(tld)
	if err := plan.Execute(); err != nil {
		return err
	}

	// Check if pf.conf needs to be updated (complex modification not in plan)
	pfConf, err := os.ReadFile("/etc/pf.conf")
	if err != nil {
		return fmt.Errorf("reading /etc/pf.conf: %w", err)
	}

	pfConfStr := string(pfConf)
	needsUpdate := false

	// Check if our anchor is already referenced
	if !strings.Contains(pfConfStr, "roost-dev") {
		needsUpdate = true

		// Create backup before modifying
		backupPath := "/etc/pf.conf.roost-dev-backup"
		fmt.Printf("Backing up /etc/pf.conf to %s...\n", backupPath)
		if err := os.WriteFile(backupPath, pfConf, 0644); err != nil {
			return fmt.Errorf("creating backup: %w", err)
		}

		fmt.Println("Updating /etc/pf.conf to include roost-dev anchor...")

		// Add anchor reference after the com.apple anchor line
		lines := strings.Split(pfConfStr, "\n")
		var newLines []string
		for _, line := range lines {
			newLines = append(newLines, line)
			if strings.Contains(line, `rdr-anchor "com.apple/*"`) {
				newLines = append(newLines, `rdr-anchor "roost-dev"`)
			}
			if strings.Contains(line, `load anchor "com.apple" from "/etc/pf.anchors/com.apple"`) {
				newLines = append(newLines, `load anchor "roost-dev" from "/etc/pf.anchors/roost-dev"`)
			}
		}

		if err := os.WriteFile("/etc/pf.conf", []byte(strings.Join(newLines, "\n")), 0644); err != nil {
			return fmt.Errorf("writing /etc/pf.conf: %w", err)
		}
	}

	// Load the LaunchDaemon so pf rules persist across reboots
	// First unload if already loaded (ignore errors)
	exec.Command("/bin/launchctl", "bootout", "system/dev.roost.pfctl").Run()
	// Then bootstrap the daemon
	if err := exec.Command("/bin/launchctl", "bootstrap", "system", launchdPlistPath).Run(); err != nil {
		return fmt.Errorf("loading LaunchDaemon (are you running as root?): %w", err)
	}

	// Enable pf and load the rules now (suppress verbose pfctl output)
	cmd := exec.Command("/sbin/pfctl", "-e", "-f", "/etc/pf.conf")
	cmd.Run() // Ignore errors - pf may already be enabled

	// Load the anchor specifically
	cmd = exec.Command("/sbin/pfctl", "-a", "roost-dev", "-f", pfAnchorPath)
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("loading anchor: %w", err)
	}

	fmt.Println()
	fmt.Println("Port forwarding installed!")
	fmt.Println("  - Port 80  → 9280 (HTTP)")
	fmt.Println("  - Port 443 → 9443 (HTTPS)")
	fmt.Printf("  - TLD: .%s\n", tld)
	if needsUpdate {
		fmt.Println()
		fmt.Println("Note: /etc/pf.conf was modified. Backup saved to /etc/pf.conf.roost-dev-backup")
	}

	return nil
}

func runPortsUninstall(tld string) error {
	// Check if already uninstalled (before prompting for sudo)
	if !isPortForwardingInstalled(tld) {
		fmt.Printf("%s✓ Port forwarding is not installed%s\n", colorGreen, colorReset)
		fmt.Println("  Not found: /etc/pf.anchors/roost-dev")
		fmt.Println("  Not found: /Library/LaunchDaemons/dev.roost.pfctl.plist")
		fmt.Printf("  Not found: /etc/resolver/%s\n", tld)
		return nil
	}

	// If not running as root, show summary and re-invoke with sudo
	if os.Geteuid() != 0 {
		// Show summary and confirm (? shows full diff)
		plan := portsUninstallPlan(tld)
		fmt.Println("Removing port forwarding requires administrator privileges.")
		if !confirmWithPlan(plan, "Proceed with removal?") {
			return fmt.Errorf("removal cancelled")
		}
		fmt.Println()

		// Find our binary
		exe, err := os.Executable()
		if err != nil {
			return fmt.Errorf("finding executable: %w", err)
		}

		// Re-invoke with sudo
		args := []string{exe, "ports", "uninstall", "--tld", tld}
		cmd := exec.Command("sudo", args...)
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		cmd.Stdin = os.Stdin
		return cmd.Run()
	}

	fmt.Println("Removing port forwarding...")

	// Flush our anchor (ignore errors - anchor may not exist)
	exec.Command("/sbin/pfctl", "-a", "roost-dev", "-F", "all").Run()

	// Unload launchd before removing plist (ignore errors - may not be loaded)
	exec.Command("/bin/launchctl", "bootout", "system/dev.roost.pfctl").Run()

	// Execute the plan for file deletion (same plan used for preview, ensuring sync)
	plan := portsUninstallPlan(tld)
	if err := plan.Execute(); err != nil {
		return err
	}

	fmt.Printf("%s✓ Port forwarding removed%s\n", colorGreen, colorReset)

	// Only mention backup if it exists
	backupPath := "/etc/pf.conf.roost-dev-backup"
	if _, err := os.Stat(backupPath); err == nil {
		fmt.Println()
		fmt.Println("Note: /etc/pf.conf still contains roost-dev references.")
		fmt.Println("To restore original pf.conf:")
		fmt.Printf("  sudo cp %s /etc/pf.conf\n", backupPath)
	}

	return nil
}
